<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>pgShark by dalibo</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>pgShark</h1>
        <p>Messing with PostgreSQL network traffic to make some usefull things</p>

        <p class="view"><a href="https://github.com/dalibo/pgshark">View the Project on GitHub <small>dalibo/pgshark</small></a></p>


        <ul>
          <li><a href="https://github.com/dalibo/pgshark/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/dalibo/pgshark/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/dalibo/pgshark">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <pre><code>pgShark is a Perl module able to mess with PostgreSQL network
traffic
</code></pre>

<h1>
<a name="synopsis" class="anchor" href="#synopsis"><span class="octicon octicon-link"></span></a>Synopsis</h1>

<p>A simple exemple to count the number of connections and disconnections on localhost, live version:</p>

<div class="highlight highlight-perl"><pre>        <span class="k">use</span> <span class="n">pgShark</span><span class="p">;</span>

        <span class="k">my</span> <span class="p">(</span><span class="nv">$cnx</span><span class="p">,</span> <span class="nv">$dcnx</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$dev</span> <span class="o">=</span> <span class="s">'lo'</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$err</span><span class="p">;</span>

        <span class="nv">$shark</span> <span class="o">=</span> <span class="n">pgShark</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">({</span>
            <span class="s">'procs'</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="s">'AuthenticationOk'</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nv">$cnx</span><span class="o">++</span><span class="p">},</span>
                <span class="s">'Terminate'</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nv">$dcnx</span><span class="o">++</span><span class="p">},</span>
            <span class="p">},</span>
            <span class="s">'host'</span> <span class="o">=&gt;</span> <span class="s">'127.0.0.1'</span><span class="p">,</span>
            <span class="s">'port'</span> <span class="o">=&gt;</span> <span class="mi">5432</span>
        <span class="p">});</span>

        <span class="nb">die</span> <span class="s">"Can not open interface $dev:\n$err"</span> <span class="k">if</span> <span class="nv">$shark</span><span class="o">-&gt;</span><span class="n">live</span><span class="p">(</span><span class="nv">$dev</span><span class="p">,</span> <span class="o">\</span><span class="nv">$err</span><span class="p">);</span>

        <span class="c1"># on live capture, a ctrl-c interrupt the loop</span>
        <span class="nv">$shark</span><span class="o">-&gt;</span><span class="n">process_all</span><span class="p">();</span>

        <span class="nv">$shark</span><span class="o">-&gt;</span><span class="nb">close</span><span class="p">();</span>

        <span class="nb">printf</span> <span class="s">"Number of connections/disconnections: %u/%u\n"</span><span class="p">,</span> <span class="nv">$cnx</span><span class="p">,</span> <span class="nv">$dcnx</span><span class="p">;</span>
</pre></div>

<h1>
<a name="description" class="anchor" href="#description"><span class="octicon octicon-link"></span></a>Description</h1>

<p>This Perl module is able to study PostgreSQL traffic captured from a
network interface and call various functions for each messages of the
protocol. The network dump could be live or from a pcap file (using
tcpdump as instance).</p>

<p>pgShark comes with various sample scripts able to do various things with
these network dumps. See help page of each of them for more
informations.</p>

<h1>
<a name="methods" class="anchor" href="#methods"><span class="octicon octicon-link"></span></a>Methods</h1>

<pre><code>*   new (\%settings)

    Static method.

    Creates a new pgShark object and returns it. It takes a hash as
    parameter with the following settings:

        {
            'host' =&gt; IP address of the server
            'port' =&gt; Port of the PostgreSQL server
            'protocol' =&gt; the protocol version, ie. 2 or 3
            'procs' =&gt; {
                # Hash of callbacks for each messages.
                'message name' =&gt; \&amp;callback
                ...
            }
            'debug' =&gt; $level
        }

    When 'host' key is not given, pgShark will wait for a message coming
    from the backend or the frontend with no doubt before calling user
    callbacks. Depending on the network activity, it can takes more or
    less time and messages might be lost (usually, COPY related ones).
    If you really need *ALL* messages, set the 'host' key explicitly.

    pgShark is not able to detect which port the server is listening.
    Default is PostgreSQL's ones, ie. 5432. Make sure to always set the
    proper port or pgShark will just filter out your PostgreSQL traffic
    if it's not on 5432.

    If not defined, the protocol version by default is 3.

    The 'procs' hash associate a callback to each messages of the
    PostgreSQL protocol you are interested in. See the following link
    about available message names and definitions:

      http://www.postgresql.org/docs/current/static/protocol-message-formats.html

    One messages type has been added to both protocols: SSLAnswer.

    The 'debug' key in settings can be set between 0 and 6, 0 is the
    default with no debug message, 6 is the most verbose. Because of
    internal performance consideration, you MUST set the environment
    variable DEBUG to '1' to actually activate the debugging messages.

*   live ($interface, \$err)

    Open a live capture on given interface from first parameter. The
    second parameter is a reference to a string. It will be filled with
    the error message if the method fails.

    Returns 0 on success, 1 on failure

*   open ($file, \$err)

    Open a given pcap file from first parameter. The second parameter is
    a reference to a string. It will be filled with the error message if
    the method fails.

    Returns 0 on success, 1 on failure.

*   close ()

    Close the pcap handle previously opened with this object using
    either pgShark::live() or pgShark::open() methods.

*   process_all ()

    Loop over all available packets from the previously opened pcap
    handle.

*   dec2dot ($ip_addr)

    Static method.

    Convert a decimal IP address representation given as first parameter
    to the human notation "ww.xx.yy.zz".

*   normalize_query ($query)

    Static method.

    Returns the normalized version of the query given as first
    parameter.
</code></pre>

<h1>
<a name="binaries" class="anchor" href="#binaries"><span class="octicon octicon-link"></span></a>Binaries</h1>

<pre><code>For details, see the output of parameter "--help" for each of them.

*   pgs-badger

    This script analyse the pcap traffics and outputs various statistics
    about what was found in PostgreSQL protocol.

    The report contains most popular queries, slowest cumulated ones,
    slowest queries ever, classification of queries by type, sessions
    time, number of connexion, errors, notices, etc.

    The network dump could be live or from a pcap file (using tcpdump
    for instance).

    In a futur version this script is supposed to talk with pgbadger
    directly !

*   pgs-debug

    Outputs the PostgreSQL messages in human readable format. Useful to
    analyze what is in a network dump before using pgshark on some other
    duties.

*   pgs-normalize

    The "pgs-normalize" script tries to normalize queries and prepared
    statements and output them to stdout. Its purpose is to give you a
    list of unique queries, whatever the number of time they have been
    sent by clients and whatever their parameters were.

*   pgs-record

    "pgs-record" filters network traffic and dump PostgreSQL related
    activity to a pcap file. The pcap file can then be processed with
    all available pgShark tools.

    "pgs-record" rely on perl Net::Pcap module. However, unlike
    Net::Pcap, "tcpdump" is able to set a bigger capture buffer using
    recent libpcap. Default buffer size is often too small to be able to
    dump all tcp datagram quickly enough. Because of this buffer size
    (1MB), on high loaded systems, you might loose packets. Therefor, by
    default, "pgs-record" will try to act as a wrapper around c&lt;tcpdump&gt;
    if it is available on the system and set the buffer to "32M".

    Capturing high throughput traffic, make sure your CPU, disks and
    memory are good enough to deal with the amount of data. You might
    want to set the capture buffer to 256MB or more and redirect
    directly to a file for future use.

*   pgs-replay

    &lt;pgs-replay&gt; send the PostgreSQL messages to a given PostgreSQL
    cluster. The network dump could be live or from a pcap file (using
    tcpdump for instance).

    This script only supports protocol v3, making it compatilible with
    versions 7.4 to 9.2 of PostgreSQL.

    This script currently does not support any kind of authentication on
    the remote PostgreSQL cluster where messages are send. Make sure it
    can connect using ident, peer or trust.

*   pgs-sql

    Writes captured queries on stdout. Because of the SQL language
    doesn't support unnamed prepared statement, this script actually try
    to names them. Presently, this script doesn't support cursors nor
    COPY messages.

*   pgs-stat

    Outputs various informations about PostgreSQL activity on the
    network on a given sampling period.
</code></pre>

<h1>
<a name="see-also" class="anchor" href="#see-also"><span class="octicon octicon-link"></span></a>See also</h1>

<pre><code>This module rely on two modules to parse message of protocols v2 and v3:
pgShark::protocol_2 and pgShark::protocol_3.
</code></pre>

<h1>
<a name="licensing" class="anchor" href="#licensing"><span class="octicon octicon-link"></span></a>LICENSING</h1>

<pre><code>This program is open source, licensed under the simplified BSD license.
For license terms, see the LICENSE provided with the sources.
</code></pre>

<h1>
<a name="authors" class="anchor" href="#authors"><span class="octicon octicon-link"></span></a>AUTHORS</h1>

<pre><code>Jehan-Guillaume de Rorthais &lt;jgdr@dalibo.com&gt;

Nicolas Thauvin &lt;nicolas.thauvin@dalibo.com&gt;

Guillaume Lelarge &lt;guillaume.lelarge@dalibo.com&gt;

Copyright: (C) 2012-2014 Jehan-Guillaume de Rorthais - All rights
reserved.

Dalibo's team. http://www.dalibo.org
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/dalibo">dalibo</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>